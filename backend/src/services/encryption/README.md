# End-to-End Encryption Service (Signal Protocol)

## Overview
This directory implements the Signal Protocol for end-to-end encrypted messaging in NeuraChat. The implementation currently supports **1-on-1 private chats only** (group chat encryption will be added in a future phase).

## Architecture

### Core Components

1. **SignalService.ts** - Core encryption logic
   - Key generation (identity, signed pre-keys, one-time pre-keys)
   - Key upload and retrieval
   - Key rotation and replenishment
   - Encryption status management

2. **SessionManager.ts** - Session state management
   - Save/load encryption sessions
   - Track active sessions
   - Session lifecycle management

## How It Works

### Key Types

1. **Identity Key (Long-term)**
   - One per user
   - Represents user's cryptographic identity
   - Public key stored on server, private key stays on client

2. **Signed Pre Key (Medium-term)**
   - Rotated periodically (every 30 days recommended)
   - Signed by identity key for authenticity
   - Used for initial key agreement

3. **One-Time Pre Keys (Short-term)**
   - Single-use keys
   - Batch of 100 uploaded at registration
   - Consumed during session initialization
   - Provides forward secrecy

4. **Session Keys (Ephemeral)**
   - Generated by Double Ratchet algorithm
   - Managed entirely client-side
   - Change with every message exchange

### Message Flow (E2EE)

```
┌─────────────────────────────────────────────────────────────┐
│                    Initial Setup (Once)                      │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  Alice (Client)                                  Server      │
│       │                                             │         │
│       │  1. Generate keys on registration          │         │
│       │     - Identity key pair                    │         │
│       │     - Signed pre-key                       │         │
│       │     - 100 one-time pre-keys                │         │
│       │                                             │         │
│       │  2. POST /api/encryption/keys              │         │
│       │─────────────────────────────────────────────>        │
│       │     (Upload PUBLIC keys only)              │         │
│       │                                             │         │
│       │  3. Keys stored in encryption_keys table   │         │
│       │<─────────────────────────────────────────────        │
│       │     Success response                       │         │
│                                                               │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│              First Message (Session Establishment)           │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  Alice                            Server              Bob    │
│    │                                 │                 │     │
│    │  1. GET /api/encryption/keys/bob-id              │     │
│    │─────────────────────────────────>                │     │
│    │     Request Bob's public keys                    │     │
│    │                                 │                 │     │
│    │  2. Returns key bundle          │                │     │
│    │<─────────────────────────────────                │     │
│    │     (identity + signed + OTP)                    │     │
│    │                                                   │     │
│    │  3. Establish session (client-side)              │     │
│    │     Using X3DH key agreement                     │     │
│    │                                                   │     │
│    │  4. Encrypt message with session key             │     │
│    │     Plaintext → Ciphertext                       │     │
│    │                                                   │     │
│    │  5. socket.emit('send-message', {                │     │
│    │       content: CIPHERTEXT })                     │     │
│    │─────────────────────────────────>                │     │
│    │                                 │                 │     │
│    │  6. Server saves CIPHERTEXT     │                │     │
│    │     (No decryption!)                             │     │
│    │                                 │                 │     │
│    │  7. Broadcast CIPHERTEXT        │                │     │
│    │                                 │───────────────────>   │
│    │                                 │                 │     │
│    │                                 │  8. Bob decrypts│     │
│    │                                 │     Ciphertext → Plaintext
│                                                               │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│               Subsequent Messages (Double Ratchet)           │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  - Session keys automatically evolve with each message       │
│  - Forward secrecy: past messages can't be decrypted         │
│  - Self-healing: security restored after key compromise      │
│  - All encryption/decryption happens CLIENT-SIDE             │
│  - Server only stores and relays CIPHERTEXT                  │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

## API Endpoints

All endpoints require authentication (JWT token in cookie).

### Key Management

#### Upload Keys
```http
POST /api/encryption/keys
Content-Type: application/json

{
  "identityKey": "base64-encoded-public-key",
  "signedPreKey": {
    "id": 1,
    "public": "base64-encoded-public-key",
    "signature": "base64-encoded-signature"
  },
  "oneTimePreKeys": [
    { "id": 0, "public": "base64..." },
    { "id": 1, "public": "base64..." },
    ...
  ]
}
```

**Response:**
```json
{
  "message": "Keys uploaded successfully",
  "prekeyCount": 100
}
```

#### Get Pre-Key Bundle
```http
GET /api/encryption/keys/:userId
```

**Response:**
```json
{
  "identityKey": "base64-encoded-public-key",
  "signedPreKey": {
    "id": 1,
    "publicKey": "base64...",
    "signature": "base64..."
  },
  "oneTimePreKey": {
    "id": 42,
    "publicKey": "base64..."
  }
}
```

**Note:** One-time pre-key is consumed (removed from server) when fetched.

#### Rotate Signed Pre-Key
```http
POST /api/encryption/rotate-prekey
Content-Type: application/json

{
  "signedPreKey": {
    "id": 2,
    "public": "base64...",
    "signature": "base64..."
  }
}
```

#### Replenish One-Time Pre-Keys
```http
POST /api/encryption/replenish-prekeys
Content-Type: application/json

{
  "oneTimePreKeys": [
    { "id": 100, "public": "base64..." },
    { "id": 101, "public": "base64..." },
    ...
  ]
}
```

#### Get Encryption Status
```http
GET /api/encryption/status
```

**Response:**
```json
{
  "hasKeys": true,
  "prekeyCount": 42,
  "lastRotation": "2025-12-09T10:30:00Z",
  "needsReplenishment": false
}
```

### Session Management

#### Initialize Session
```http
POST /api/encryption/session/:contactId
```

**Response:**
```json
{
  "message": "Session initialized successfully",
  "alreadyExists": false
}
```

#### Delete Session
```http
DELETE /api/encryption/session/:contactId
```

#### Get Active Sessions
```http
GET /api/encryption/sessions
```

**Response:**
```json
{
  "sessions": [
    {
      "contactId": "user-uuid-1",
      "updatedAt": "2025-12-09T10:30:00Z"
    },
    {
      "contactId": "user-uuid-2",
      "updatedAt": "2025-12-09T09:15:00Z"
    }
  ]
}
```

## Database Schema

### encryption_keys
Stores users' public keys.

```sql
create table public.encryption_keys (
  id uuid primary key,
  user_id uuid references users(id) not null,
  identity_key text not null,
  signed_pre_key text not null,
  one_time_pre_keys jsonb,
  updated_at timestamptz default now()
);
```

### encryption_sessions
Tracks active encryption sessions (optional, for server-side session metadata).

```sql
create table public.encryption_sessions (
  id uuid primary key,
  user_id uuid references users(id) not null,
  contact_id uuid references users(id) not null,
  session_state jsonb not null,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  unique(user_id, contact_id)
);
```

### used_prekeys
Audit log of consumed one-time pre-keys.

```sql
create table public.used_prekeys (
  id uuid primary key,
  user_id uuid references users(id) not null,
  prekey_id text not null,
  used_by uuid references users(id) not null,
  used_at timestamptz default now(),
  unique(user_id, prekey_id)
);
```

### key_rotation_logs
Audit log of key rotations.

```sql
create table public.key_rotation_logs (
  id uuid primary key,
  user_id uuid references users(id) not null,
  key_type text check (key_type in ('identity', 'signed_pre_key', 'one_time_pre_keys')),
  rotated_at timestamptz default now(),
  reason text
);
```

## Security Principles

### ✅ DO:
- Store only **public keys** on server
- Encrypt messages **client-side** before sending
- Decrypt messages **client-side** after receiving
- Validate all key uploads
- Rotate signed pre-keys periodically (every 30 days)
- Replenish one-time pre-keys when low (< 20 remaining)

### ❌ DON'T:
- Never send private keys to server
- Never decrypt messages server-side
- Never log plaintext message content
- Never share keys between users without proper protocol
- Never reuse one-time pre-keys

## Client Implementation Guide

### 1. Registration Flow

```typescript
import * as SignalClient from '@signalapp/libsignal-client';

// Generate keys
const identityKey = SignalClient.PrivateKey.generate();
const signedPreKey = generateSignedPreKey(identityKey, 1);
const oneTimePreKeys = generateOneTimePreKeys(0, 100);

// Store private keys locally (IndexedDB or encrypted storage)
await storePrivateKeys({
  identity: identityKey.serialize(),
  signedPreKey: signedPreKey.privateKey
});

// Upload public keys to server
await fetch('/api/encryption/keys', {
  method: 'POST',
  credentials: 'include',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    identityKey: identityKey.getPublicKey().serialize().toString('base64'),
    signedPreKey: {
      id: signedPreKey.keyId,
      public: signedPreKey.publicKey.toString('base64'),
      signature: signedPreKey.signature.toString('base64')
    },
    oneTimePreKeys: oneTimePreKeys.map(k => ({
      id: k.keyId,
      public: k.publicKey.toString('base64')
    }))
  })
});
```

### 2. Sending First Message

```typescript
// Fetch recipient's keys
const bundle = await fetch(`/api/encryption/keys/${recipientId}`, {
  credentials: 'include'
}).then(r => r.json());

// Initialize session using X3DH
const session = await initializeSessionWithBundle(bundle);

// Encrypt message
const plaintext = 'Hello, Bob!';
const ciphertext = await session.encrypt(Buffer.from(plaintext, 'utf8'));

// Send via Socket.IO
socket.emit('send-message', {
  chat_id: chatId,
  sender_id: myUserId,
  content: ciphertext.serialize().toString('base64'),
  type: 'text'
});
```

### 3. Receiving and Decrypting

```typescript
socket.on('new-message', async (message) => {
  // Load session with sender
  const session = await loadSession(message.sender_id);
  
  if (!session) {
    // First message from this sender - initialize session
    const bundle = await fetch(`/api/encryption/keys/${message.sender_id}`);
    session = await initializeSessionWithBundle(bundle);
  }
  
  // Decrypt message
  const ciphertext = Buffer.from(message.content, 'base64');
  const plaintext = await session.decrypt(ciphertext);
  
  // Display decrypted message
  console.log('Decrypted:', plaintext.toString('utf8'));
});
```

## Maintenance

### Key Rotation Schedule

- **Signed Pre-Key**: Rotate every 30 days
- **One-Time Pre-Keys**: Replenish when < 20 remaining
- **Identity Key**: Never rotate (unless compromised)

### Monitoring

Check encryption status regularly:
```typescript
const status = await fetch('/api/encryption/status', {
  credentials: 'include'
}).then(r => r.json());

if (status.needsReplenishment) {
  // Generate and upload new one-time pre-keys
}
```

## Limitations

### Current Implementation
- ✅ 1-on-1 private chats
- ❌ Group chats (requires Sender Keys protocol)
- ❌ Media file encryption (planned)
- ❌ Key backup/restore (planned)
- ❌ Safety number verification (planned)

### Future Enhancements
- Group chat encryption using Sender Keys
- Encrypted media file support
- Key backup mechanism
- Safety number verification UI
- Session fingerprint display
- Automatic key rotation scheduler

## Troubleshooting

### "User keys not found"
**Cause:** User hasn't uploaded keys after registration.  
**Fix:** Call `POST /api/encryption/keys` after user creation.

### "Session initialization failed"
**Cause:** No one-time pre-keys available.  
**Fix:** Replenish via `POST /api/encryption/replenish-prekeys`.

### "Decryption failed"
**Cause:** Session state out of sync or corrupted.  
**Fix:** Delete and re-initialize session.

## References

- [Signal Protocol Specification](https://signal.org/docs/)
- [libsignal-client Documentation](https://github.com/signalapp/libsignal)
- [X3DH Key Agreement Protocol](https://signal.org/docs/specifications/x3dh/)
- [Double Ratchet Algorithm](https://signal.org/docs/specifications/doubleratchet/)

---

**Status:** ✅ Backend implementation complete for 1-on-1 chats  
**Next:** Frontend integration (key generation, session management, encryption/decryption)
