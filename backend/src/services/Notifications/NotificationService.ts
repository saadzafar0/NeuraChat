import { supabase } from '../../config/database';
import { io } from '../../server'; 
import { UUID } from 'crypto'; 

// Define types based on your EERD
export type NotificationType = 'message' | 'call' | 'system' | 'ai_summary';

export interface CreateNotificationDTO {
  userId: string;
  type: NotificationType;
  title: string;
  content: string | object; 
  relatedId?: string; 
}

export class NotificationService {
  
  static async createNotification(data: CreateNotificationDTO) {
    try {
      // 1. Validation
      if (!data.userId || !data.type) {
        throw new Error('Missing required notification fields');
      }

      const { data: savedNotification, error } = await supabase
        .from('notifications')
        .insert({
          user_id: data.userId,
          type: data.type,
          title: data.title,
          content: typeof data.content === 'object' ? JSON.stringify(data.content) : data.content,
          is_read: false,
          // created_at is auto-generated by Postgres
        })
        .select()
        .single();

      if (error) {
        console.error('Supabase Notification Error:', error);
        throw new Error(error.message);
      }

      // 3. Real-Time Emission (Observer Pattern)
      // We emit to the specific user room defined in server.ts: "user:{userId}"
      if (io) {
        io.to(`user:${data.userId}`).emit('notification:new', savedNotification);
      } else {
        console.warn('Socket.io instance not found, skipping real-time emission');
      }

      return savedNotification;

    } catch (err: any) {
      console.error('Notification Service Error:', err.message);
      return null;
    }
  }

  //Fetch notification history for a user
  static async getUserNotifications(userId: string, limit = 20, offset = 0) {
    const { data, error, count } = await supabase
      .from('notifications')
      .select('*', { count: 'exact' })
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) throw new Error(error.message);
    
    return { notifications: data, total: count };
  }

  // Mark specific notification as read
  static async markAsRead(notificationId: string, userId: string) {
    const { data, error } = await supabase
      .from('notifications')
      .update({ is_read: true })
      .eq('id', notificationId)
      .eq('user_id', userId) 
      .select()
      .single();

    if (error) throw new Error(error.message);
    return data;
  }

  // Mark ALL as read (Bulk Action)
  static async markAllAsRead(userId: string) {
    const { error } = await supabase
      .from('notifications')
      .update({ is_read: true })
      .eq('user_id', userId)
      .eq('is_read', false);

    if (error) throw new Error(error.message);
    return { success: true };
  }
}